from sympy import *


C = Matrix([[4, 3],
            [1, 2]])
"""G的对偶矩阵，基矢量的对偶基矢量，符合g1.gd1 =1 gd1.g2 = 0"""
C_dual = C**-1
print("C.dual=====================")
pprint(C_dual)
pprint(C_dual * C)
print("dual base vector===========")
g1 = C.col(0)
g2 = C.col(1)
gd1 = C_dual.row(0)
gd2 = C_dual.row(1)
pprint(gd1.dot(g1))
pprint(gd1.dot(g2))

print("metrics tensor=============")
"""度量张量的两种求法**************************"""
"""用基向量的点积做分量"""
G_c = C.T * C
pprint(G_c)
"""
通过并矢，得到的是度量张量还是什么？dyadic tensor
"""

"""求1,1在直角坐标系的读数********************"""
v = Matrix([1, 1])
"""在直角坐标系中的读数"""
v_oth = C * v
"""在直角坐标系中的长度"""
pprint(v_oth.dot(v_oth))

"""用度量张量求对偶读数*************************"""
v_dual = G_c * v
"""对偶读数求直角长度。对偶坐标系的读数有修补的作用，你放大我缩小，你缩小我放大"""
pprint(v.dot(v_dual))

"""求逆矩阵的新方法？"""
print("Inverse matrix============")
pprint(C_dual)
pprint(G_c*C)


"""
将g1,g2用gd1,gd2表示，这也会形成一个矩阵，这个矩阵是不是度量张量？
这里其实是很奇怪的，两个矢量就可以做并矢了，得到的是什么？所以，拿四个矢量做并矢，得到的又是什么？

如果把度量张量写全了，是不是并矢张量的表达式？ 比方说用坐标变换的角度来写
[gd_x]  = [g11 g12] . [g_x]
[gd_y]    [g21 g22]   [g_y]

这个式子的本质含义是。度量张量看起来就是一次坐标变换啊。是将当前基向量写成其对偶坐标系的读数。
这样，给定一个向量当前坐标系的读数，就可以获取其对偶坐标系的读数。

为什么点乘可以得到当前基向量在对偶坐标系的读数呢？
g1.g1 = 第一个基向量在其对偶基矢量上的平行四边形分量。这不是投影，也不是点乘，而是平行四边形分解的量。
因为对偶基矢量的定义是 gd1.g1 = 1, gd1.g2 = 0

为什么会是平行四边形分解的量呢？
对任意矢量，在基矢量中分解的式子P = p1.g1+p2.g2 = pd1.gd1 + pd2.gd2
如果将两边分别点乘其对偶基矢量P.g1 = pd1.gd1.g1 + pd2.gd2.g1 = pd1, 可见这个点乘单纯的得到了P的gd1上的平行四边形分量。
同理，如果点乘g2，式子就只剩下了pd2.

那么这个几何解释是什么？漂亮的部分要来了。因为如果平行四边形投影还刚好涉及到g2（因为在gd1的投影需要平行于gd2）, 而g2和gd1是垂直的。


P.g1的几何含义又是什么呢？ 它是P在g1上面的投影的长度乘以g1的长度。但这并不是P在g1上面的平行四边形分量哦。


g2.g1=是第一个基向量在其第二个对偶基矢量上的分量，即投影？

[xd].gd1  = [g1.g1 g1.g2] . [x] = x.g1.g1  + y.g1.g2
[yd].gd2    [g2.g1 g2.g2]   [y]   x.g2.g1    y.g2.g2
"""